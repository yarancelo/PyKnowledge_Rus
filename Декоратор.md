Декораторы в Python позволяют расширять и изменять поведение вызываемых объектов([[Функции|функций]], [[Классы|классов]], [[Метод|методов]]) без изменения самого вызываемого объекта.
Любая сторонняя функциональность, которую можно прикрепить к поведению существующего класса или функции является примером использования декораторов:
* [[Логгирование]]
* Обеспечение контроля доступа и аутентификации
* Инструментарий и функции управления временем
* Ограничение времени
* Кеширование
* И т.п.

Декораторы оборачивает другую функцию и позволяют выполнять код до и после вызова оборачиваемой функции. Декораторы позволяют определять повторно используемые модули, которые могут изменять или расширять поведение других функций. Поведение функции изменяется только когда она декорируется.
```Python
def null_decorator(func):
  return func
```

В данном примере, null_decorator является вызываемым объектом, он принимает на вход другой вызываемый объект и возвращает его не изменяя.
```Python
def greet():
  return "Hello!"

greet = null_decorator(greet)
print(greet())
```

Функция greet() в данном примере была передана в функцию null_decorator() и записана в переменную, после чего вызвана. В данном примере null_decorator ничего не делает. 
Есть более удобный синтаксис для использования декораторов, в нем используется строка @null_decorator. Данная запись является эквивалентом записи выше:
```Python
def null_decorator(func):
  return func

@null_decorator
def greet():
  return "hello"

print(greet())
```

В следующем примере используется декоратор для преобразования вывода оригинальной функции в заглавные буквы:
```Python
def uppercase(func):
  def wrapper():
    original_result = func()
    modified_result = original_result.upper()
    return modified_result
  return wrapper

@uppercase
def greet():
  return "hello"

print(greet())
```
Синтаксис с промежуточной функцией-оберткой (wrapper) позволяет изменить поведение оригинальной функции, таким образом, что wrapper получает строку из greet и превращает ее в большие буквы, после чего wrapper возвращает новую строку. Следующий пример показывает это наглядно: 
```Python
def decorator(func):
  def wrapper():
    print("Before function call")
    func()
    print("After function call")
  return wrapper

@decorator
def say_hello():
  print("Привет!")

say_hello()
```
 Внутри функции обертки у нас появляется возможность исполнить код до и после вызова функции, переданной как аргумент.

Декораторы могут быть сколько угодно большой вложенности. В примере ниже показан декоратор с тройным уровнем вложенности и декораторы применяются в порядке снизу вверх.
```Python
def uppercase(func):
  def wrapper():
    original_result = func()
    modified_result = original_result.upper()
    return modified_result
  return wrapper

def strong(func):
  def wrapper():
    return "<strong>" + func() + "</strong>"
  return wrapper

def emphasis(func):
  def wrapper():
    return '<em>' + func() + '</em>'
  return wrapper

@strong
@emphasis
@uppercase
def greet():
  return "hello"

print(greet())
```
Вывод в консоль: ```<strong><em>HELLO</em></strong>```.

### **Декорирование функций принимающих аргументы**
Wrapper декоратора, принимающего функцию с аргументами, принимает их как [[Функции#^86f3b1|*args, **kwargs]]. Эти аргументы используется для сбора всех позиционных и ключевых аргументов и хранения их в переменных args и kwargs.
```Python
def arg_decorator(func):
  def wrapper(*args, **kwargs):
    return func(*args, **kwargs)
  return wrapper
```

Более практический пример:
```Python
def trace(func):
  def wrapper(*args, **kwargs):
    print(f'TRACE: calling {func.__name__}() with {args}, {kwargs}')
    original_result = func(*args, **kwargs)
    print(f'TRACE: {func.__name__}() returned {original_result!r}')
    return original_result
  return wrapper

@trace
def say(name, line):
  return f'{name}: {line}'

say("Vladimir", "Hello world")
```
Вывод в консоль:
```TRACE: calling say() with ('Vladimir', 'Hello world'), {}
TRACE: say() returned 'Vladimir: Hello world'
```

### **Декорирование и [[Атрибуты|атрибуты]]**
Когда функция оборачивается в декоратор, мы теряем доступ к ее оригинальным атрибутам:
```Python
print(say.__name__)
``` 
Вывод в консоль: ```wrapper```. 
То есть, обращаясь к атрибутам функции say(), благодаря обертке мы получили ее атрибуты. Это может мешать, например, при откладке кода, и для решения этой проблемы можно воспользоваться встроенным модулем [[Модуль functools|functools]]:
```python
import functools

def trace(func):
  @functools.wraps(func)
  def wrapper(*args, **kwargs):
    print(f'TRACE: calling {func.__name__}() with {args}, {kwargs}')
    original_result = func(*args, **kwargs)
    print(f'TRACE: {func.__name__}() returned {original_result!r}')
    return original_result
  return wrapper

@trace
def say(name, line):
  return f'{name}: {line}'

print(say.__name__)
```
Вывод в консоль: ```say```.
То есть теперь мы получаем оригинальный атрибут вызываемой функции.